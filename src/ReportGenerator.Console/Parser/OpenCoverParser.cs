using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;
using System.Xml.XPath;
using Palmmedia.ReportGenerator.Common;
using Palmmedia.ReportGenerator.Logging;
using Palmmedia.ReportGenerator.Parser.Analysis;
using Palmmedia.ReportGenerator.Properties;

namespace Palmmedia.ReportGenerator.Parser
{
    /// <summary>
    /// Parser for XML reports generated by OpenCover.
    /// </summary>
    internal class OpenCoverParser : ParserBase
    {
        /// <summary>
        /// Regex to analyze if a method name belongs to a lamda expression.
        /// </summary>
        private const string LambdaMethodRegex = "::<.+>.+__";

        /// <summary>
        /// The Logger.
        /// </summary>
        private static readonly ILogger Logger = LoggerFactory.GetLogger(typeof(OpenCoverParser));

        /// <summary>
        /// The module elements of the report.
        /// </summary>
        private XElement[] modules;

        /// <summary>
        /// The file elements of the report.
        /// </summary>
        private XElement[] files;

        /// <summary>
        /// The tracked methods by id.
        /// </summary>
        private IDictionary<string, string> trackedMethods;

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenCoverParser"/> class.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        /// <param name="parserOptions">Options related to how the report is parsed.</param>
        internal OpenCoverParser(XContainer report, IParserOptions parserOptions = null)
        {
            if (report == null)
            {
                throw new ArgumentNullException(nameof(report));
            }

            this.modules = report.Descendants("Module")
                .Where(m => m.Attribute("skippedDueTo") == null)
                .ToArray();
            this.files = report.Descendants("File").ToArray();
            this.trackedMethods = report.Descendants("TrackedMethod")
                .ToDictionary(t => t.Attribute("uid").Value, t => t.Attribute("name").Value);

            var assemblyNames = this.modules
                .Select(m => m.Element("ModuleName").Value)
                .Distinct()
                .OrderBy(a => a)
                .ToArray();

            Parallel.ForEach(assemblyNames, assemblyName => this.AddAssembly(this.ProcessAssembly(assemblyName, parserOptions)));

            this.modules = null;
            this.files = null;
            this.trackedMethods = null;
        }

        /// <summary>
        /// Gets a value indicating whether the used parser supports branch coverage.
        /// </summary>
        /// <value>
        /// <c>true</c> if used parser supports branch coverage; otherwise, <c>false</c>.
        /// </value>
        public override bool SupportsBranchCoverage => true;

        /// <summary>
        /// Extracts the metrics from the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="methods">The methods.</param>
        /// <param name="class">The class.</param>
        private static void SetMethodMetrics(IEnumerable<XElement> methods, Class @class)
        {
            foreach (var methodGroup in methods.GroupBy(m => m.Element("Name").Value))
            {
                var method = methodGroup.First();

                // Exclude properties and lambda expressions
                if (method.Attribute("skippedDueTo") != null
                    || method.HasAttributeWithValue("isGetter", "true")
                    || method.HasAttributeWithValue("isSetter", "true")
                    || Regex.IsMatch(methodGroup.Key, LambdaMethodRegex))
                {
                    continue;
                }

                var metrics = new List<Metric>()
                {
                    new Metric(
                        ReportResources.CyclomaticComplexity,
                        ParserBase.CyclomaticComplexityUri,
                        MetricType.CodeQuality,
                        methodGroup.Max(m => int.Parse(m.Attribute("cyclomaticComplexity").Value, CultureInfo.InvariantCulture))),
                    new Metric(
                        ReportResources.SequenceCoverage,
                        ParserBase.CodeCoverageUri,
                        MetricType.CoveragePercentual,
                        methodGroup.Max(m => decimal.Parse(m.Attribute("sequenceCoverage").Value, CultureInfo.InvariantCulture))),
                    new Metric(
                        ReportResources.BranchCoverage,
                        ParserBase.CodeCoverageUri,
                        MetricType.CoveragePercentual,
                        methodGroup.Max(m => decimal.Parse(m.Attribute("branchCoverage").Value, CultureInfo.InvariantCulture)))
                };

                var npathComplexityAttributes = methodGroup.Select(m => m.Attribute("nPathComplexity")).Where(a => a != null).ToArray();

                if (npathComplexityAttributes.Length > 0)
                {
                    metrics.Insert(
                        1,
                        new Metric(
                        ReportResources.NPathComplexity,
                        ParserBase.NPathComplexityUri,
                        MetricType.CodeQuality,
                        npathComplexityAttributes.Max(a => int.Parse(a.Value, CultureInfo.InvariantCulture))));
                }

                var crapScoreAttributes = methodGroup.Select(m => m.Attribute("crapScore")).Where(a => a != null).ToArray();
                if (crapScoreAttributes.Length > 0)
                {
                    metrics.Add(new Metric(
                        ReportResources.CrapScore,
                        ParserBase.CrapScoreUri,
                        MetricType.CodeQuality,
                        crapScoreAttributes.Max(a => decimal.Parse(a.Value, CultureInfo.InvariantCulture))));
                }

                @class.AddMethodMetric(new MethodMetric(ExtractMethodName(methodGroup.Key), metrics));
            }
        }

        /// <summary>
        /// Gets the branches by line number.
        /// </summary>
        /// <param name="methods">The methods.</param>
        /// <param name="fileIds">The file ids of the class.</param>
        /// <param name="parserOptions">Options related to how the coverage is calculated.</param>
        /// <returns>The branches by line number.</returns>
        private static Dictionary<int, ICollection<Branch>> GetBranches(XElement[] methods, HashSet<string> fileIds, IParserOptions parserOptions)
        {
            var result = new Dictionary<int, ICollection<Branch>>();

            var branchPoints = methods
                .Elements("BranchPoints")
                .Elements("BranchPoint").ToList();

            if (parserOptions != null && parserOptions.ImplicitBranchCoverage)
            {
                AddBranchPointsForImplicitBranches(methods, branchPoints);
            }

            // OpenCover supports this since version 4.5.3207
            if (branchPoints.Count() == 0 || branchPoints.First().Attribute("sl") == null)
            {
                return result;
            }

            foreach (var branchPoint in branchPoints)
            {
                if (branchPoint.Attribute("fileid") != null
                    && !fileIds.Contains(branchPoint.Attribute("fileid").Value))
                {
                    // If fileid is available, verify that branch belongs to same file (available since version OpenCover.4.5.3418)
                    continue;
                }

                int lineNumber = int.Parse(branchPoint.Attribute("sl").Value, CultureInfo.InvariantCulture);

                string identifier = string.Format(
                    CultureInfo.InvariantCulture,
                    "{0}_{1}_{2}_{3}",
                    lineNumber,
                    branchPoint.Attribute("path").Value,
                    branchPoint.Attribute("offset").Value,
                    branchPoint.Attribute("offsetend").Value);

                var branch = new Branch(
                    int.Parse(branchPoint.Attribute("vc").Value, CultureInfo.InvariantCulture),
                    identifier);

                ICollection<Branch> branches = null;
                if (result.TryGetValue(lineNumber, out branches))
                {
                    HashSet<Branch> branchesHashset = (HashSet<Branch>)branches;
                    if (branchesHashset.Contains(branch))
                    {
                        // Not perfect for performance, but Hashset has no GetElement method
                        branchesHashset.First(b => b.Equals(branch)).BranchVisits += branch.BranchVisits;
                    }
                    else
                    {
                        branches.Add(branch);
                    }
                }
                else
                {
                    branches = new HashSet<Branch>();
                    branches.Add(branch);

                    result.Add(lineNumber, branches);
                }
            }

            return result;
        }

        /// <summary>
        /// Adds branch points for implicit branches (i.e. methods with no branches as such, have some code to be touched).
        /// </summary>
        /// <param name="methods">Method nodes</param>
        /// <param name="branchPointsCollection">The collection of branch points.</param>
        private static void AddBranchPointsForImplicitBranches(XElement[] methods, IList<XElement> branchPointsCollection)
        {
            var validMethods = methods.Where(m => m.Element("FileRef") != null && 
                                                  !m.Element("BranchPoints").HasElements);

            foreach (var method in validMethods)
            {
                var fileId = method.Element("FileRef").Attribute("uid").Value;

                string vc = "0";

                // if any sequence point has non-zero visited count, consider that branch visited status for the implicit branch.
                if (method.XPathSelectElement("./SequencePoints/SequencePoint[@vc != '0']") != null)
                {
                    vc = "1";
                }

                // to link branch by line, pick the line number of first sequence point (i.e. first line of the method).
                var firstSeqPoint = method.XPathSelectElement("./SequencePoints/SequencePoint");
                var sl = (firstSeqPoint != null) ? firstSeqPoint.Attribute("sl").Value : "0";
                var newBranchPoint = new XElement("BranchPoint", 
                    new XAttribute("vc", vc),
                    new XAttribute("fileid", fileId),
                    new XAttribute("uspid", "0"),
                    new XAttribute("path", "0"),
                    new XAttribute("ordinal", "0"),
                    new XAttribute("offset", "0"),
                    new XAttribute("offsetend", "0"),
                    new XAttribute("sl", sl));

                branchPointsCollection.Add(newBranchPoint);
            }
        }

        /// <summary>
        /// Extracts the methods/properties of the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="codeFile">The code file.</param>
        /// <param name="methodsOfFile">The methods of the file.</param>
        private static void SetCodeElements(CodeFile codeFile, IEnumerable<XElement> methodsOfFile)
        {
            foreach (var method in methodsOfFile)
            {
                if (method.Attribute("skippedDueTo") != null
                    || Regex.IsMatch(method.Element("Name").Value, LambdaMethodRegex))
                {
                    continue;
                }

                string methodName = ExtractMethodName(method.Element("Name").Value);
                methodName = methodName.Substring(methodName.LastIndexOf(':') + 1);

                CodeElementType type = CodeElementType.Method;

                if (method.HasAttributeWithValue("isGetter", "true")
                    || method.HasAttributeWithValue("isSetter", "true"))
                {
                    type = CodeElementType.Property;
                    methodName = methodName.Substring(4);
                }

                var seqpnt = method
                    .Elements("SequencePoints")
                    .Elements("SequencePoint")
                    .FirstOrDefault();

                if (seqpnt != null)
                {
                    int line = int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture);
                    codeFile.AddCodeElement(new CodeElement(methodName, type, line));
                }
            }
        }

        /// <summary>
        /// Extracts the method name. For async methods the original name is returned.
        /// </summary>
        /// <param name="methodName">The full method name.</param>
        /// <returns>The method name.</returns>
        private static string ExtractMethodName(string methodName)
        {
            Match match = Regex.Match(methodName, @"<(?<CompilerGeneratedName>.+)>.+__.+::MoveNext\(\)$");

            if (match.Success)
            {
                methodName = match.Groups["CompilerGeneratedName"].Value + "()";
            }

            return methodName;
        }

        /// <summary>
        /// Processes the given assembly.
        /// </summary>
        /// <param name="assemblyName">Name of the assembly.</param>
        /// <param name="parserOptions">Options related to parsing.</param>
        /// <returns>The <see cref="Assembly"/>.</returns>
        private Assembly ProcessAssembly(string assemblyName, IParserOptions parserOptions)
        {
            Logger.DebugFormat("  " + Resources.CurrentAssembly, assemblyName);

            var fileIdsByFilename = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(assemblyName))
                .Elements("Files")
                .Elements("File")
                .GroupBy(f => f.Attribute("fullPath").Value, f => f.Attribute("uid").Value)
                .ToDictionary(g => g.Key, g => g.ToHashSet());

            var classNames = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(assemblyName))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => !c.Element("FullName").Value.Contains("<")
                    && c.Attribute("skippedDueTo") == null)
                .Select(c =>
                    {
                        string fullname = c.Element("FullName").Value;
                        int nestedClassSeparatorIndex = fullname.IndexOf('/');
                        return nestedClassSeparatorIndex > -1 ? fullname.Substring(0, nestedClassSeparatorIndex) : fullname;
                    })
                .Distinct()
                .OrderBy(name => name)
                .ToArray();

            var assembly = new Assembly(assemblyName);

            Parallel.ForEach(classNames, className => assembly.AddClass(this.ProcessClass(fileIdsByFilename, assembly, className, parserOptions)));

            return assembly;
        }

        /// <summary>
        /// Processes the given class.
        /// </summary>
        /// <param name="fileIdsByFilename">Dictionary containing the file ids by filename.</param>
        /// <param name="assembly">The assembly.</param>
        /// <param name="className">Name of the class.</param>
        /// <param name="parserOptions">Options related to the parsing.</param>
        /// <returns>The <see cref="Class"/>.</returns>
        private Class ProcessClass(Dictionary<string, HashSet<string>> fileIdsByFilename, Assembly assembly, string className, IParserOptions parserOptions)
        {
            var methods = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(assembly.Name))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => c.Element("FullName").Value.Equals(className)
                            || c.Element("FullName").Value.StartsWith(className + "/", StringComparison.Ordinal))
                .Elements("Methods")
                .Elements("Method");

            var fileIdsOfClassInSequencePoints = methods
                .Elements("SequencePoints")
                .Elements("SequencePoint")
                .Where(seqpnt => seqpnt.Attribute("fileid") != null
                                 && seqpnt.Attribute("fileid").Value != "0")
                .Select(seqpnt => seqpnt.Attribute("fileid").Value)
                .ToArray();

            // Only required for backwards compatibility, older versions of OpenCover did not apply fileid for partial classes
            var fileIdsOfClassInFileRef = methods
                .Where(m => m.Element("FileRef") != null)
                .Select(m => m.Element("FileRef").Attribute("uid").Value)
                .ToArray();

            var fileIdsOfClass = fileIdsOfClassInSequencePoints
                .Concat(fileIdsOfClassInFileRef)
                .Distinct()
                .ToHashSet();

            var filesOfClass = this.files
                .Where(file => fileIdsOfClass.Contains(file.Attribute("uid").Value))
                .Select(file => file.Attribute("fullPath").Value)
                .Distinct()
                .ToArray();

            var @class = new Class(className, assembly);

            foreach (var file in filesOfClass)
            {
                @class.AddFile(this.ProcessFile(fileIdsByFilename[file], @class, file, parserOptions));
            }

            @class.CoverageQuota = this.GetCoverageQuotaOfClass(assembly, className);

            return @class;
        }

        /// <summary>
        /// Processes the file.
        /// </summary>
        /// <param name="fileIds">The file ids of the class.</param>
        /// <param name="class">The class.</param>
        /// <param name="filePath">The file path.</param>
        /// <param name="parserOptions">options related to how coverage is calculated.</param>
        /// <returns>The <see cref="CodeFile"/>.</returns>
        private CodeFile ProcessFile(HashSet<string> fileIds, Class @class, string filePath, IParserOptions parserOptions)
        {
            var methods = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(@class.Assembly.Name))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => c.Element("FullName").Value.Equals(@class.Name)
                            || c.Element("FullName").Value.StartsWith(@class.Name + "/", StringComparison.Ordinal))
                .Elements("Methods")
                .Elements("Method")
                .ToArray();

            var methodsOfFile = methods
                .Where(m => m.Element("FileRef") != null && fileIds.Contains(m.Element("FileRef").Attribute("uid").Value))
                .ToArray();

            SetMethodMetrics(methodsOfFile, @class);

            var seqpntsOfFile = methods
                .Elements("SequencePoints")
                .Elements("SequencePoint")
                .Where(seqpnt => (seqpnt.Attribute("fileid") != null
                                    && fileIds.Contains(seqpnt.Attribute("fileid").Value))
                    || (seqpnt.Attribute("fileid") == null && seqpnt.Parent.Parent.Element("FileRef") != null
                        && fileIds.Contains(seqpnt.Parent.Parent.Element("FileRef").Attribute("uid").Value)))
                .Select(seqpnt => new
                {
                    LineNumberStart = int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture),
                    LineNumberEnd = seqpnt.Attribute("el") != null ? int.Parse(seqpnt.Attribute("el").Value, CultureInfo.InvariantCulture) : int.Parse(seqpnt.Attribute("sl").Value, CultureInfo.InvariantCulture),
                    Visits = int.Parse(seqpnt.Attribute("vc").Value, CultureInfo.InvariantCulture),
                    TrackedMethodRefs = seqpnt.Elements("TrackedMethodRefs")
                        .Elements("TrackedMethodRef")
                        .Select(t => new
                        {
                            Visits = int.Parse(t.Attribute("vc").Value, CultureInfo.InvariantCulture),
                            TrackedMethodId = t.Attribute("uid").Value
                        })
                })
                .OrderBy(seqpnt => seqpnt.LineNumberEnd)
                .ToArray();

            var branches = GetBranches(methods, fileIds, parserOptions);

            var coverageByTrackedMethod = seqpntsOfFile
                .SelectMany(s => s.TrackedMethodRefs)
                .Select(t => t.TrackedMethodId)
                .Distinct()
                .ToDictionary(id => id, id => new CoverageByTrackedMethod { Coverage = new int[] { }, LineVisitStatus = new LineVisitStatus[] { } });

            int[] coverage = new int[] { };
            LineVisitStatus[] lineVisitStatus = new LineVisitStatus[] { };

            if (seqpntsOfFile.Length > 0)
            {
                coverage = new int[seqpntsOfFile[seqpntsOfFile.LongLength - 1].LineNumberEnd + 1];
                lineVisitStatus = new LineVisitStatus[seqpntsOfFile[seqpntsOfFile.LongLength - 1].LineNumberEnd + 1];

                for (int i = 0; i < coverage.Length; i++)
                {
                    coverage[i] = -1;
                }

                foreach (var trackedMethodCoverage in coverageByTrackedMethod)
                {
                    trackedMethodCoverage.Value.Coverage = (int[])coverage.Clone();
                    trackedMethodCoverage.Value.LineVisitStatus = new LineVisitStatus[seqpntsOfFile[seqpntsOfFile.LongLength - 1].LineNumberEnd + 1];
                }

                foreach (var seqpnt in seqpntsOfFile)
                {
                    for (int lineNumber = seqpnt.LineNumberStart; lineNumber <= seqpnt.LineNumberEnd; lineNumber++)
                    {
                        int visits = coverage[lineNumber] == -1 ? seqpnt.Visits : coverage[lineNumber] + seqpnt.Visits;
                        coverage[lineNumber] = visits;

                        if (lineVisitStatus[lineNumber] != LineVisitStatus.Covered)
                        {
                            bool partiallyCovered = false;

                            ICollection<Branch> branchesOfLine = null;

                            // Use 'LineNumberStart' instead of 'lineNumber' here. Branches have line number of first line of seqpnt
                            if (branches.TryGetValue(seqpnt.LineNumberStart, out branchesOfLine))
                            {
                                partiallyCovered = branchesOfLine.Any(b => b.BranchVisits == 0);
                            }

                            LineVisitStatus statusOfLine = visits > 0 ? (partiallyCovered ? LineVisitStatus.PartiallyCovered : LineVisitStatus.Covered) : LineVisitStatus.NotCovered;
                            lineVisitStatus[lineNumber] = (LineVisitStatus)Math.Max((int)lineVisitStatus[lineNumber], (int)statusOfLine);
                        }

                        if (visits > -1)
                        {
                            foreach (var trackedMethodCoverage in coverageByTrackedMethod)
                            {
                                if (trackedMethodCoverage.Value.Coverage[lineNumber] == -1)
                                {
                                    trackedMethodCoverage.Value.Coverage[lineNumber] = 0;
                                    trackedMethodCoverage.Value.LineVisitStatus[lineNumber] = LineVisitStatus.NotCovered;
                                }
                            }
                        }

                        foreach (var trackedMethod in seqpnt.TrackedMethodRefs)
                        {
                            var trackedMethodCoverage = coverageByTrackedMethod[trackedMethod.TrackedMethodId];

                            int trackeMethodVisits = trackedMethodCoverage.Coverage[lineNumber] == -1 ? trackedMethod.Visits : trackedMethodCoverage.Coverage[lineNumber] + trackedMethod.Visits;
                            LineVisitStatus statusOfLine = trackeMethodVisits > 0 ? (LineVisitStatus)Math.Min((int)LineVisitStatus.Covered, (int)lineVisitStatus[lineNumber]) : LineVisitStatus.NotCovered;

                            trackedMethodCoverage.Coverage[lineNumber] = trackeMethodVisits;
                            trackedMethodCoverage.LineVisitStatus[lineNumber] = statusOfLine;
                        }
                    }
                }
            }

            var codeFile = new CodeFile(filePath, coverage, lineVisitStatus, branches);

            foreach (var trackedMethodCoverage in coverageByTrackedMethod)
            {
                string name = null;

                // Sometimes no corresponding MethodRef element exists
                if (this.trackedMethods.TryGetValue(trackedMethodCoverage.Key, out name))
                {
                    string shortName = name.Substring(name.Substring(0, name.IndexOf(':') + 1).LastIndexOf('.') + 1);
                    TestMethod testMethod = new TestMethod(name, shortName);
                    codeFile.AddCoverageByTestMethod(testMethod, trackedMethodCoverage.Value);
                }
            }

            SetCodeElements(codeFile, methodsOfFile);

            return codeFile;
        }

        /// <summary>
        /// Gets the coverage quota of a class.
        /// This method is used to get coverage quota if line coverage is not available.
        /// </summary>
        /// <param name="assembly">The assembly.</param>
        /// <param name="className">Name of the class.</param>
        /// <returns>The coverage quota.</returns>
        private decimal? GetCoverageQuotaOfClass(Assembly assembly, string className)
        {
            var methodGroups = this.modules
                .Where(m => m.Element("ModuleName").Value.Equals(assembly.Name))
                .Elements("Classes")
                .Elements("Class")
                .Where(c => c.Element("FullName").Value.Equals(className)
                            || c.Element("FullName").Value.StartsWith(className + "/", StringComparison.Ordinal))
                .Elements("Methods")
                .Elements("Method")
                .Where(m => m.Attribute("skippedDueTo") == null && m.Element("FileRef") == null && !m.Element("Name").Value.EndsWith(".ctor()", StringComparison.OrdinalIgnoreCase))
                .GroupBy(m => m.Element("Name").Value)
                .ToArray();

            int visitedMethods = methodGroups.Count(g => g.Any(m => m.Attribute("visited").Value == "true"));

            return (methodGroups.Length == 0) ? (decimal?)null : (decimal)Math.Truncate(1000 * (double)visitedMethods / (double)methodGroups.Length) / 10;
        }
    }
}
