using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using System.Xml.Linq;
using Palmmedia.ReportGenerator.Core.Logging;
using Palmmedia.ReportGenerator.Core.Parser.Analysis;
using Palmmedia.ReportGenerator.Core.Parser.Filtering;
using Palmmedia.ReportGenerator.Core.Properties;

namespace Palmmedia.ReportGenerator.Core.Parser
{
    /// <summary>
    /// Parser for XML reports generated by Testwell CTC.
    /// </summary>
    internal class CtcParser : ParserBase
    {
        /// <summary>
        /// The Logger.
        /// </summary>
        private static readonly ILogger Logger = LoggerFactory.GetLogger(typeof(CtcParser));

        /// <summary>
        /// Initializes a new instance of the <see cref="CtcParser" /> class.
        /// </summary>
        /// <param name="assemblyFilter">The assembly filter.</param>
        /// <param name="classFilter">The class filter.</param>
        /// <param name="fileFilter">The file filter.</param>
        internal CtcParser(IFilter assemblyFilter, IFilter classFilter, IFilter fileFilter)
            : base(assemblyFilter, classFilter, fileFilter)
        {
        }

        /// <summary>
        /// Parses the given XML report.
        /// </summary>
        /// <param name="report">The XML report.</param>
        /// <returns>The parser result.</returns>
        public ParserResult Parse(XContainer report)
        {
            if (report == null)
            {
                throw new ArgumentNullException(nameof(report));
            }

            var assemblies = new List<Assembly>();

            var root = report.Element("file")?.Parent;

            if (root != null)
            {
                string name = root.Attribute("projectName").Value;

                if (this.AssemblyFilter.IsElementIncludedInReport(name))
                {
                    assemblies.Add(this.ProcessAssembly(new XElement[] { root }, name));
                }
            }

            var result = new ParserResult(assemblies.OrderBy(a => a.Name).ToList(), true, this.ToString());

            return result;
        }

        /// <summary>
        /// Processes the given assembly.
        /// </summary>
        /// <param name="modules">The modules.</param>
        /// <param name="assemblyName">Name of the assembly.</param>
        /// <returns>The <see cref="Assembly"/>.</returns>
        private Assembly ProcessAssembly(XElement[] modules, string assemblyName)
        {
            Logger.DebugFormat(Resources.CurrentAssembly, assemblyName);

            var files = modules
                .Where(m => m.Attribute("projectName").Value.Equals(assemblyName))
                .Elements("file")
                .Where(f => this.FileFilter.IsElementIncludedInReport(f.Attribute("name").Value))
                .OrderBy(f => f.Attribute("name").Value)
                .ToArray();

            var assembly = new Assembly(assemblyName);

            Parallel.ForEach(files, file => this.ProcessFile(assembly, file));

            return assembly;
        }

        /// <summary>
        /// Processes the file.
        /// </summary>
        /// <param name="assembly">The assembly.</param>
        /// <param name="fileElement">The file element.</param>
        private void ProcessFile(Assembly assembly, XElement fileElement)
        {
            string className = fileElement.Attribute("name").Value;

            int indexOfFileExtension = className.LastIndexOf(".");

            if (indexOfFileExtension > 0)
            {
                className = className.Substring(0, indexOfFileExtension);
            }

            if (!this.ClassFilter.IsElementIncludedInReport(className))
            {
                return;
            }

            var @class = new Class(className, assembly);

            var lines = fileElement.Elements("function")
                .Where(f => !string.IsNullOrEmpty(f.Attribute("name")?.Value))
                .Elements("line")
                .ToArray();

            var linesOfFile = lines
                .Where(line => line.Attribute("codeType").Value == "Executable")
                .Select(line => new
                {
                    LineNumber = int.Parse(line.Attribute("number").Value, CultureInfo.InvariantCulture),
                    Visits = line.Attribute("isExecuted").Value == "Executed" ? 1 : 0
                })
                .OrderBy(seqpnt => seqpnt.LineNumber)
                .ToArray();
            var branches = GetBranches(lines);

            int[] coverage = new int[] { };
            LineVisitStatus[] lineVisitStatus = new LineVisitStatus[] { };

            if (linesOfFile.Length > 0)
            {
                coverage = new int[linesOfFile[linesOfFile.LongLength - 1].LineNumber + 1];
                lineVisitStatus = new LineVisitStatus[linesOfFile[linesOfFile.LongLength - 1].LineNumber + 1];

                for (int i = 0; i < coverage.Length; i++)
                {
                    coverage[i] = -1;
                }

                foreach (var line in linesOfFile)
                {
                    coverage[line.LineNumber] = line.Visits;

                    bool partiallyCovered = false;

                    if (branches.TryGetValue(line.LineNumber, out ICollection<Branch> branchesOfLine))
                    {
                        partiallyCovered = branchesOfLine.Any(b => b.BranchVisits == 0);
                    }

                    LineVisitStatus statusOfLine = line.Visits > 0 ? (partiallyCovered ? LineVisitStatus.PartiallyCovered : LineVisitStatus.Covered) : LineVisitStatus.NotCovered;
                    lineVisitStatus[line.LineNumber] = statusOfLine;
                }
            }

            var methodsOfFile = fileElement
                .Elements("function")
                .ToArray();

            var codeFile = new CodeFile(fileElement.Attribute("location").Value, coverage, lineVisitStatus, branches);

            SetMethodMetrics(codeFile, methodsOfFile);
            SetCodeElements(codeFile, methodsOfFile);
            SetCtcDetails(codeFile, methodsOfFile);

            @class.AddFile(codeFile);

            assembly.AddClass(@class);
        }

        /// <summary>
        /// Extracts the metrics from the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="codeFile">The code file.</param>
        /// <param name="methodsOfFile">The methods of the file.</param>
        private static void SetMethodMetrics(CodeFile codeFile, IEnumerable<XElement> methodsOfFile)
        {
            foreach (var method in methodsOfFile)
            {
                var measures = method.Elements("measure").ToArray();

                if (measures.Length == 0)
                {
                    continue;
                }

                var metrics = new List<Metric>();

                var mcdcMeasure = measures.FirstOrDefault(m => m.Attribute("name").Value.Equals("MC/DC", StringComparison.OrdinalIgnoreCase));

                if (mcdcMeasure != null)
                {
                    decimal? value = Math.Round(decimal.Parse(mcdcMeasure.Value.TrimEnd('%'), CultureInfo.InvariantCulture), 2, MidpointRounding.AwayFromZero);
                    metrics.Add(Metric.Mcdc(value));
                }

                var decisionMeasure = measures.FirstOrDefault(m => m.Attribute("name").Value.Equals("Decision", StringComparison.OrdinalIgnoreCase));

                if (decisionMeasure != null)
                {
                    decimal? value = Math.Round(decimal.Parse(decisionMeasure.Value.TrimEnd('%'), CultureInfo.InvariantCulture), 2, MidpointRounding.AwayFromZero);
                    metrics.Add(Metric.Decision(value));
                }

                var statementMeasure = measures.FirstOrDefault(m => m.Attribute("name").Value.Equals("Statement", StringComparison.OrdinalIgnoreCase));

                if (statementMeasure != null)
                {
                    decimal? value = Math.Round(decimal.Parse(statementMeasure.Value.TrimEnd('%'), CultureInfo.InvariantCulture), 2, MidpointRounding.AwayFromZero);
                    metrics.Add(Metric.Statement(value));
                }

                if (metrics.Count == 0)
                {
                    continue;
                }

                string methodName = method.Attribute("name").Value;

                var methodMetric = new MethodMetric(methodName, methodName, metrics);

                var line = method
                    .Elements("line")
                    .FirstOrDefault();

                if (line != null)
                {
                    methodMetric.Line = int.Parse(line.Attribute("number").Value, CultureInfo.InvariantCulture);
                }

                codeFile.AddMethodMetric(methodMetric);
            }
        }

        /// <summary>
        /// Extracts the methods/properties of the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="codeFile">The code file.</param>
        /// <param name="methodsOfFile">The methods of the file.</param>
        private static void SetCodeElements(CodeFile codeFile, IEnumerable<XElement> methodsOfFile)
        {
            foreach (var method in methodsOfFile)
            {
                string methodName = method.Attribute("name").Value;

                if (string.IsNullOrEmpty(methodName))
                {
                    continue;
                }

                var lines = method
                    .Elements("line")
                    .Where(line => line.Attribute("codeType").Value == "Executable")
                    .ToArray();

                if (lines.Length == 0)
                {
                    continue;
                }

                int firstLine = int.Parse(lines.First().Attribute("number").Value, CultureInfo.InvariantCulture);
                int lastLine = int.Parse(lines.Last().Attribute("number").Value, CultureInfo.InvariantCulture);

                codeFile.AddCodeElement(new CodeElement(
                    methodName,
                    methodName,
                    CodeElementType.Method,
                    firstLine,
                    lastLine,
                    codeFile.CoverageQuotaInRange(firstLine, lastLine)));
            }
        }

        /// <summary>
        /// Extracts the CTC specific details of the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="codeFile">The code file.</param>
        /// <param name="methodsOfFile">The methods of the file.</param>
        private static void SetCtcDetails(CodeFile codeFile, IEnumerable<XElement> methodsOfFile)
        {
            foreach (var method in methodsOfFile)
            {
                string methodName = method.Attribute("name").Value;

                if (string.IsNullOrEmpty(methodName))
                {
                    continue;
                }

                var lines = method
                    .Elements("line")
                    .Where(line => line.Attribute("codeType").Value == "Executable")
                    .ToArray();

                if (lines.Length == 0)
                {
                    continue;
                }

                foreach (var line in lines)
                {
                    var levelDecisionProbe = line.Elements("probe")
                    .FirstOrDefault();

                    if (levelDecisionProbe == null)
                    {
                        continue;
                    }

                    var tfcombinations = levelDecisionProbe
                        .Elements("tfcombination")
                        .Select(x => new CtcProbeDetail(
                            x.Attribute("achieved").Value == "Achieved",
                            x.Element("description").Value))
                        .ToList();

                    var mcdcs = levelDecisionProbe
                        .Elements("mcdc")
                        .Select(x => new CtcProbeDetail(
                            x.Attribute("achieved").Value == "Achieved",
                            x.Element("description").Value))
                        .ToList();

                    if (tfcombinations.Count > 0 || mcdcs.Count > 0)
                    {
                        var ctcDetails = new CtcDetails(
                            tfcombinations,
                            mcdcs);

                        int lineNumber = int.Parse(line.Attribute("number").Value, CultureInfo.InvariantCulture);

                        codeFile.AddCtcDetail(lineNumber, ctcDetails);
                    }
                }
            }
        }

        /// <summary>
        /// Gets the branches by line number.
        /// </summary>
        /// <param name="lines">The lines.</param>
        /// <returns>The branches by line number.</returns>
        private static Dictionary<int, ICollection<Branch>> GetBranches(IEnumerable<XElement> lines)
        {
            var result = new Dictionary<int, ICollection<Branch>>();

            foreach (var line in lines)
            {
                var levelDecisionProbe = line.Elements("probe")
                    .FirstOrDefault();

                if (levelDecisionProbe == null)
                {
                    continue;
                }

                var trueCountElement = levelDecisionProbe.Attribute("trueCount");
                var falseCountElement = levelDecisionProbe.Attribute("falseCount");

                // Both counts must be present, otherwise it is not a branch
                if (trueCountElement == null
                    || string.IsNullOrEmpty(trueCountElement.Value)
                    || falseCountElement == null
                    || string.IsNullOrEmpty(falseCountElement.Value))
                {
                    continue;
                }

                var tfcombinations = levelDecisionProbe
                    .Elements("tfcombination")
                    .ToArray();

                int numberOfCoveredBranches = 0;
                int numberOfTotalBranches = 0;

                if (tfcombinations.Length > 0)
                {
                    numberOfCoveredBranches = tfcombinations.Count(tc => tc.Attribute("achieved").Value == "Achieved");
                    numberOfTotalBranches = tfcombinations.Length;
                }
                else
                {
                    numberOfCoveredBranches = int.Parse(trueCountElement.Value, CultureInfo.InvariantCulture)
                        + int.Parse(falseCountElement.Value, CultureInfo.InvariantCulture);
                    numberOfTotalBranches = 2;
                }

                int lineNumber = int.Parse(line.Attribute("number").Value, CultureInfo.InvariantCulture);

                var branches = new HashSet<Branch>();

                for (int i = 0; i < numberOfTotalBranches; i++)
                {
                    string identifier = string.Format(
                        CultureInfo.InvariantCulture,
                        "{0}_{1}",
                        lineNumber,
                        i);

                    branches.Add(new Branch(i < numberOfCoveredBranches ? 1 : 0, identifier));
                }

                result.Add(lineNumber, branches);
            }

            return result;
        }
    }
}
